
#include<iostream>
#include<sstream>
#include<fstream>
using namespace std;
#include <iomanip>
#include <sys/stat.h>
#include <cmath>
#include <TError.h>
#include <TF1.h>
#include <TROOT.h>
#include <TStyle.h>
#include <TApplication.h>
#include <TFile.h>
#include <TCanvas.h>
#include <TTree.h>
#include <TClonesArray.h>
#include <TObject.h>
#include <TEventList.h>
#include <TBranch.h>
#include <TRandom3.h>
#include <TH1.h>
#include <TH2.h>
#include <TH3.h>
#include <TVector.h>
#include <TLegend.h>
#include <TGraph.h>
#include <TGaxis.h>
#include <TMarker.h>
#include <TText.h>
#include <TMath.h>
#include <TSpectrum.h>
#include <TBox.h>
#include <TLatex.h>
#include <TString.h>
#include <TSystem.h>
#include <THStack.h>
int LimitTracks=20;
int LimitRecs=10;
int NDials=175;
#include "TApplication.h"
#include "INGRIDEVENTSUMMARY.h"
#include "IngridHitSummary.h"
#include "IngridSimHitSummary.h"
#include "IngridSimVertexSummary.h"
#include "IngridSimParticleSummary.h"
#include "BeamInfoSummary.h"
#include "IngridBasicReconSummary.h"
#include "INGRID_Dimension.cc"
INGRID_Dimension * IngDim = new INGRID_Dimension();
#include "setup.h"
#include "Hit.h"
#include "PMdispRev.h"
#include "Corrections.cc"
#include "Reconstruction.cc"
#include "Xsec.cc"

Reconstruction * Rec = new Reconstruction();
Corrections * Cor = new Corrections();
Xsec * XS = new Xsec();
//#define ALLSTUDY
//#define DEBUG
#define XSEC_ERROR
//#define GENERATEWIDTH
//double C[17]={-1.85,0.34,0.59,0.74,0.514,-0.37,1.25,-0.06,0.562,0.82,-0.47,0.6,-0.57,-0.45};
TSpline3 * s_PMIng; TSpline3 * s_PMSci;TSpline3 * s_Ing;
TF1 * f_PMIng;TF1 * f_PMSci;TF1 * f_Ing;
TF1 * CL_PMIng;TF1 * CL_PMSci;TF1 * CL_Ing;
Double_t fPDF_Ing(Double_t *pe, Double_t *par){
  if(s_Ing->Eval(pe[0])>=0){ return s_Ing->Eval(pe[0])/par[0];}
  else {return 0;}
}
Double_t fPDF_PMIng(Double_t *pe, Double_t *par){
  if(s_PMIng->Eval(pe[0])>=0){ return s_PMIng->Eval(pe[0])/par[0];}
  else {return 0;}
}
Double_t fPDF_PMSci(Double_t *pe, Double_t *par){
  if(s_PMSci->Eval(pe[0])>=0){ return s_PMSci->Eval(pe[0])/par[0];}
  else {return 0;}
}

Double_t Cumulative_Ing(Double_t *pe, Double_t *par){
  if(pe[0]>=par[1]){ return (1.-f_Ing->Integral(par[1],pe[0])/f_Ing->Integral(par[1],par[2]));}
  else{ return (1.-f_Ing->Integral(pe[0],par[1])/f_Ing->Integral(par[0],par[1]));}
}
Double_t Cumulative_PMIng(Double_t *pe, Double_t *par){
  if(pe[0]>=par[1]){ return (1.-f_PMIng->Integral(par[1],pe[0])/f_PMIng->Integral(par[1],par[2]));}
  else{ return (1.-f_PMIng->Integral(pe[0],par[1])/f_PMIng->Integral(par[0],par[1]));}
}
Double_t Cumulative_PMSci(Double_t *pe, Double_t *par){
  if(pe[0]>=par[1]){ return (1.-f_PMSci->Integral(par[1],pe[0])/f_PMSci->Integral(par[1],par[2]));}
  else{ return (1.-f_PMSci->Integral(pe[0],par[1])/f_PMSci->Integral(par[0],par[1]));}
}

Double_t Cumulative_Ing_KS(Double_t *pe, Double_t *par){
  return (1.-f_Ing->Integral(par[0],pe[0])/f_Ing->Integral(par[0],par[1]));
}
Double_t Cumulative_PMIng_KS(Double_t *pe, Double_t *par){
  return (1.-f_PMIng->Integral(par[0],pe[0])/f_PMIng->Integral(par[0],par[1]));
}
Double_t Cumulative_PMSci_KS(Double_t *pe, Double_t *par){
  return (1.-f_PMSci->Integral(par[0],pe[0])/f_PMSci->Integral(par[0],par[1]));
}

void LoadMuCLDistributions(){
  /********************************Load MuCL************************************/
  TFile * file = new TFile("/home/bquilain/CC0pi_XS/XS/src/PDFMuCL.root");
  s_PMIng = (TSpline3*) file->Get("s_PMIng");
  s_PMSci = (TSpline3*) file->Get("s_PMSci");
  s_Ing = (TSpline3*) file->Get("s_Ing");
  
  double Start_PMIng=s_PMIng->GetXmin();double End_PMIng=s_PMIng->GetXmax();
  double Start_PMSci=s_PMSci->GetXmin();double End_PMSci=s_PMSci->GetXmax();
  double Start_Ing=s_Ing->GetXmin();double End_Ing=s_Ing->GetXmax();
  f_PMIng = new TF1("f_PMIng",fPDF_PMIng,Start_PMIng,End_PMIng,1);
  f_PMSci = new TF1("f_PMSci",fPDF_PMSci,Start_PMSci,End_PMSci,1);                                                                                                                          
  f_Ing = new TF1("f_Ing",fPDF_Ing,Start_Ing,End_Ing,1);
  f_PMIng->SetParameter(0,1.);
  f_PMSci->SetParameter(0,1.);
  f_Ing->SetParameter(0,1.);

  double MaxX_PMIng=f_PMIng->GetMaximumX(Start_PMIng,End_PMIng);
  double MaxX_PMSci=f_PMSci->GetMaximumX(Start_PMSci,End_PMSci);
  double MaxX_Ing=f_Ing->GetMaximumX(Start_Ing,End_Ing);
  /*
  CL_PMIng = new TF1("CL_PMIng",Cumulative_PMIng,Start_PMIng,End_PMIng,3);
  CL_PMSci = new TF1("CL_PMSci",Cumulative_PMSci,Start_PMSci,End_PMSci,3);
  CL_Ing = new TF1("CL_Ing",Cumulative_Ing,Start_Ing,End_Ing,3);
  CL_PMIng->SetParameter(0,Start_PMIng);CL_PMIng->SetParameter(1,MaxX_PMIng);CL_PMIng->SetParameter(2,End_PMIng);
  CL_PMSci->SetParameter(0,Start_PMSci);CL_PMSci->SetParameter(1,MaxX_PMSci);CL_PMSci->SetParameter(2,End_PMSci);
  CL_Ing->SetParameter(0,Start_Ing);CL_Ing->SetParameter(1,MaxX_Ing);CL_Ing->SetParameter(2,End_Ing);
*/
  CL_PMIng = new TF1("CL_PMIng",Cumulative_PMIng_KS,Start_PMIng,End_PMIng,2);
  CL_PMSci = new TF1("CL_PMSci",Cumulative_PMSci_KS,Start_PMSci,End_PMSci,2);
  CL_Ing = new TF1("CL_Ing",Cumulative_Ing_KS,Start_Ing,End_Ing,2);
  CL_PMIng->SetParameter(0,Start_PMIng);CL_PMIng->SetParameter(1,End_PMIng);
  CL_PMSci->SetParameter(0,Start_PMSci);CL_PMSci->SetParameter(1,End_PMSci);
  CL_Ing->SetParameter(0,Start_Ing);CL_Ing->SetParameter(1,End_Ing);
//////////////////////////////////////////////////////////////////////////////////////////////////////////
}

bool IsINGRID(int ch){
  bool Ing;
  if(ch<=7||ch>=24) Ing=true;
  else Ing=false;
  return Ing;
}

int GetMax(vector <int> V){
  int Max;
  if(V[0]>V[1] && V[0]>V[2]) Max=0;
  else if(V[0]>V[1] && V[0]<V[2])Max=2;
  else if(V[0]<V[1] && V[1]>V[2])Max=1;
  else if(V[0]<V[1] && V[1]<V[2])Max=2;
  return Max;
}

double DegRad(double angle){
  return angle*TMath::Pi()/180.;
}

double RadDeg(double angle){
  return angle*180./TMath::Pi();
}
//


int main(int argc, char **argv)
{
  ////////////TEMP
  double LowX=0;double HighX=0;double LowX_Ing=0;double HighX_Ing=0;
  int n_LowX=0;int n_HighX=0;int n_LowX_Ing=0;int n_HighX_Ing=0;
  /////////////////
  
  bool Disp=false;
  int NeutrinoType=0;
  int IntModule=0;

  int c=-1;
  bool MC=false;
  bool SystematicPE=false;
  int RandomIteration=-1;
  string RandomIteration_string;
  bool SystematicInefficiency=false;
  string InputFileName;string OutputFileName;

  while ((c = getopt(argc, argv, "i:o:f:n:dmr:a")) != -1) {
    switch(c){
    case 'i':
      InputFileName=optarg;
      break;
    case 'o':
      OutputFileName=optarg;
      break;
    case 'f':
      NeutrinoType=atoi(optarg);
      break;
    case 'n':
      IntModule=atoi(optarg);
      break;
    case 'd':
      Disp=true;
      break;
    case 'm':
      MC=true;
      break;
    case 'r':
      SystematicPE=true;
      RandomIteration=atoi(optarg);
      RandomIteration_string=optarg;
      break;
    case 'a':
      SystematicInefficiency=true;
      break;
    }
  }



  double Nu_E;
  double TrueParticleNRJ=0;
  IngridEventSummary* evt = new IngridEventSummary();
  TBranch * Br;
  IngridSimVertexSummary * simver;//il y a un numéro. On peut donc bien avoir plusieurs simvert/periode d'integ ;-)?
  IngridSimParticleSummary * SimPart;
  BeamInfoSummary * BeamSummary;
  PMAnaSummary * recon;	
  TTree * tree;

  //////////////////////////////////////
  LoadMuCLDistributions();
  /*
  TCanvas * alo = new TCanvas();
  f_PMIng->SetNpx(500);
  f_PMIng->SaveAs("testf.root");
  cout<<f_PMIng->Eval(16.8)<<endl;
  */
  int FSIInt=-1;
  int Num_Int=-1;
  int nTracks=-1;
  double weight=1;
  bool IsFV=false;
  bool IsDetected=false;
  bool IsSand=false;
  bool IsAnti=false;
  bool IsNuE=false;
  bool IsBkgH=false;
  bool IsBkgV=false;
  double POT;
  double Enu;
  double TrueAngleMuon;
  double TrueMomentumMuon;
  int NIngBasRec;
  int GoodSpill;
  int Spill;
  int VnTracks[LimitRecs];
  bool VIsDetected[LimitRecs];
  bool VSelectionOV[LimitRecs];
  bool VSelectionFV[LimitRecs];
  double TrackAngle[LimitRecs][LimitTracks];
  int TypeOfTrack[LimitRecs][LimitTracks];
  double CLMuon[LimitRecs][LimitTracks];
  int NHits_PMIng[LimitRecs][LimitTracks];
  int NHits_PMSci[LimitRecs][LimitTracks];
  int NHits_Ing[LimitRecs][LimitTracks];
  int LastChannelINGRIDX[LimitRecs][LimitTracks];
  int LastChannelINGRIDY[LimitRecs][LimitTracks];
  double TrackWidth[LimitRecs][LimitTracks];
  double Momentum[LimitRecs][LimitTracks];
  double ID[LimitRecs][LimitTracks];
  double PD[LimitRecs][LimitTracks];
  int Sample[LimitRecs][LimitTracks];
  double CriteriaAngleX[LimitRecs][LimitTracks];
  double CriteriaAngleY[LimitRecs][LimitTracks];
  double CriteriaHalfWayX[LimitRecs][LimitTracks];
  double CriteriaHalfWayY[LimitRecs][LimitTracks];

  double ReWeight[NDials];
  bool IsReconstructed[LimitRecs][LimitTracks];
  bool GT[LimitRecs][LimitTracks];


  TFile * wfile = new TFile((OutputFileName).c_str(),"recreate");
  //if(SystematicPE==false) wfile    = new TFile(( ((std::string)"plots/PM/PID")+NFiles_string+"FinalTree"+NFiles_string2+".root").c_str(),"recreate");
  //else wfile    = new TFile(( ((std::string)"plots/PM/PID")+NFiles_string+"FinalTree_"+NFiles_string2+"_PE"+RandomIteration_string+".root").c_str(),"recreate");
  /*
  TFile * wfile;
    if(MC){
      if(SystematicPE) wfile = new TFile(( ((std::string)"CC0piTree_")+NFiles_string2+"_PE"+RandomIteration_string+".root").c_str(),"recreate");
      if(SystematicInefficiency) wfile = new TFile(( ((std::string)"CC0piTree_")+NFiles_string2+"_Inefficiency.root").c_str(),"recreate");
      else wfile    = new TFile(( ((std::string)"CC0piTreeMEC")+NFiles_string2+".root").c_str(),"recreate");
  }
  else{
    sprintf(Name,"CC0piTree_%d.root",run);
    wfile = new TFile(Name,"recreate");
  }
*/
  
  TTree*              wtree    = new TTree("wtree","wtree");
  wtree->SetDirectory(wfile);
  wtree              -> Branch   ("InteractionType",&Num_Int,"Num_Int/I");
  wtree              -> Branch   ("nIngBasRec",&NIngBasRec,"nIngBasRec/I");
  wtree              -> Branch   ("FSIInt",&FSIInt,"FSIInt/I");
  wtree              -> Branch   ("nTracks[10]",VnTracks,"nTracks[10]/I");
  wtree              -> Branch   ("weight",&weight,"weight/D");
  wtree              -> Branch   ("ReWeight[175]",&ReWeight,"ReWeight[175]/D");
  wtree              -> Branch   ("IsFV",&IsFV,"IsFV/O");
  wtree              -> Branch   ("IsSand",&IsSand,"IsSand/O");
  wtree              -> Branch   ("IsAnti",&IsAnti,"IsAnti/O");
  wtree              -> Branch   ("IsNuE",&IsNuE,"IsNuE/O");
  wtree              -> Branch   ("IsBkgH",&IsBkgH,"IsBkgH/O");
  wtree              -> Branch   ("IsBkgV",&IsBkgV,"IsBkgV/O"); 
 wtree              -> Branch   ("IsDetected[10]",&VIsDetected,"IsDetected[10]/O");
  wtree              -> Branch   ("SelectionFV[10]",&VSelectionFV,"SelectionFV[10]/O");
  wtree              -> Branch   ("SelectionOV[10]",&VSelectionOV,"SelectionOV[10]/O");
  wtree              -> Branch   ("POT",&POT,"POT/D");
  wtree              -> Branch   ("GoodSpill",&GoodSpill,"GoodSpill/I");
  wtree              -> Branch   ("Spill",&Spill,"Spill/I");
  wtree              -> Branch   ("Enu",&Enu,"Enu/D");
  wtree              -> Branch   ("TrueAngleMuon",&TrueAngleMuon,"TrueAngleMuon/D");
  wtree              -> Branch   ("TrueMomentumMuon",&TrueMomentumMuon,"TrueMomentumMuon/D");
  wtree              -> Branch   ("TrackWidth[10][20]",&TrackWidth,"TrackWidth[10][20]/D");
  //wtree              -> Branch   ("IngPln[10][20]",&IngPln,"IngPln[10][20]/I");
  //wtree              -> Branch   ("StopPM[10][20]",&StopPM,"StopPM[10][20]/D");
  wtree              -> Branch   ("TrackAngle[10][20]",&TrackAngle,"TrackAngle[10][20]/D");
  wtree              -> Branch   ("TypeOfTrack[10][20]",&TypeOfTrack,"TypeOfTrack[10][20]/I");
  wtree              -> Branch   ("Sample[10][20]",&Sample,"Sample[10][20]/I");
  wtree              -> Branch   ("CLMuon[10][20]",&CLMuon,"CLMuon[10][20]/D"); 
  //wtree              -> Branch   ("NHits_PMIng[10][20]",&NHits_PMIng,"NHits_PMIng[10][20]/I"); 
  //wtree              -> Branch   ("NHits_PMSci[10][20]",&NHits_PMSci,"NHits_PMSci[10][20]/I"); 
  //wtree              -> Branch   ("NHits_Ing[10][20]",&NHits_Ing,"NHits_Ing[10][20]/I"); 
  wtree              -> Branch   ("LastChannelINGRIDX[10][20]",&LastChannelINGRIDX,"LastChannelINGRIDX[10][20]/I");                 
  wtree              -> Branch   ("LastChannelINGRIDY[10][20]",&LastChannelINGRIDY,"LastChannelINGRIDY[10][20]/I");                 
 
  wtree              -> Branch   ("Momentum[10][20]",&Momentum,"Momentum[10][20]/D");
  wtree              -> Branch   ("IronDistance[10][20]",&ID,"IronDistance[10][20]/D");
  wtree              -> Branch   ("PlasticDistance[10][20]",&PD,"PlasticDistance[10][20]/D");
  wtree              -> Branch   ("IsReconstructed[10][20]",&IsReconstructed,"IsReconstructed[10][20]/O");
  wtree              -> Branch   ("GeometricTrack[10][20]",&GT,"GeometricTrack[10][20]/O");                    
  wtree              -> Branch   ("CriteriaAngleX[10][20]",&CriteriaAngleX,"CriteriaAngleX[10][20]/D");
  wtree              -> Branch   ("CriteriaAngleY[10][20]",&CriteriaAngleY,"CriteriaAngleY[10][20]/D");
  wtree              -> Branch   ("CriteriaHalfWayX[10][20]",&CriteriaHalfWayX,"CriteriaHalfWayX[10][20]/D");
  wtree              -> Branch   ("CriteriaHalfWayY[10][20]",&CriteriaHalfWayY,"CriteriaHalfWayY[10][20]/D");

#ifdef XSEC_ERROR  
    TTree * weightstree;
    int nevt_weightstree;
    TArrayF * reweight = NULL;
    TBranch * Br_reweight;
    TArrayF * reweight1 = NULL;
    TBranch * Br_reweight1;
#endif



  TH1D * Flux = new TH1D("Flux","",2,0,2);
  TH1D * POTCount = new TH1D("POTCount","",2,0,2);
  double FluxTot=0;




  vector < vector <double> > Random;
  for(int i=0;i<Random.size();i++) Random[i].clear();
  Random.clear();
  vector <double> Temp;

  if(SystematicPE){
    for(int ch=1;ch<=3;ch++){
      TFile * _File; TH1D * _hPE;
      if(ch==1){
	_File = new TFile("InputFinal2/Difference_ChargeXAngle_PMIng.root");
	_hPE = (TH1D*) _File->Get("Difference_ChargeXAngle_PMIng");
      }
      else if(ch==2){
	_File = new TFile("InputFinal2/Difference_ChargeXAngle_PMSci.root");
        _hPE = (TH1D*) _File->Get("Difference_ChargeXAngle_PMSci");
      }
      else{
	_File = new TFile("InputFinal2/Difference_ChargeXAngle_Ing.root");
        _hPE = (TH1D*) _File->Get("Difference_ChargeXAngle_Ing");
      }
      Temp.clear();
      for(int BinAngle=0;BinAngle<30;BinAngle++){
	/*	sprintf(FileName,"Input/InputPM/GausPM[%d][%d].root",BinAngle,type);
	sprintf(HistName,"GausPM[%d][%d]",BinAngle,type);
	TFile * _file= new TFile(FileName);
	Gaus[BinAngle][type] = (TF1*) _file->Get(HistName);
	Temp.push_back(Gaus[BinAngle][type]->GetRandom());
	*/
	Temp.push_back(_hPE->GetBinContent(BinAngle+1));
	//Random[type].push_back(Gaus[BinAngle][type]->GetRandom());
	//cout<<"Channel="<<type<<", Angle="<<BinAngle*3<<", Random="<<Temp[BinAngle]<<endl;
      }
      Random.push_back(Temp);
      _File->Close();
    }
  }


  cout<<"Welcome"<<endl;
  vector <HitTemp> HitV;
  TApplication theApp("App",0,0);
  int TrackSample;

  cout<<"Opening Events"<<endl;
  cout<<"For now, we are not trying to deal with shared hits (2 tracks passing in the same scintillators)"<<endl;
  cout<<"CAREFUL: change the weight to take into account regions where there is also INGRID type scintillators"<<endl;
  cout<<"Careful: Mom3 in Simpart is always Kinetic Energy. I calculated formula that link it to momentum. TruePartNRJ in the code is in fact the momentum here"<<endl;

  ////////////////////////////////////////PREPARE THE INPUT TREE AND BRANCHES////////////////////////////////////////////////
  TFile * _file0 = new TFile((InputFileName).c_str(),"read");
  if(_file0->IsOpen()) cout << _file0->GetName() <<" is open"<< endl ;
  else{cout<<"Not able to read the file"<<endl; return 0;}
  tree=(TTree*) _file0->Get("tree");
  tree->SetDirectory(_file0);
  if(tree!=tree){cout<<"Problem in reading the tree, seems not to be any"<<endl;return 0;}
  int nevt=(int) tree->GetEntries();
  cout<<"Total Number Of Events="<<nevt<<endl;

#ifdef XSEC_ERROR
  /*
    sprintf(Name,"../New_ReWeight/T2KReWeight_v1r13/SKweightMEC%d.root",n);
    TFile * _file1 = new TFile(Name);
    if(_file1->IsOpen()) cout << _file1->GetName() <<" is open"<< endl ;
    else{cout<<"No file containing the cross section error effects"<<endl; return 0;}

    weightstree=(TTree*) _file1->Get("weightstree");
    if(weightstree!=weightstree) continue;
    nevt_weightstree=(int) weightstree->GetEntries();
    if(nevt_weightstree!=nevt) cout<<"Problem in weights tree: number of events different from Input reconstructed files. Are you sure to have input the correct weightstree?"<<endl;
    
    reweight = NULL;
    Br_reweight = weightstree->GetBranch("weights");
    Br_reweight->SetAddress(&reweight);
    weightstree->SetBranchAddress("weights",&reweight);
    
    Br_reweight1 = weightstree->GetBranch("brNSystNucl_PilessDcyRES");
    Br_reweight1->SetAddress(&reweight1);
    weightstree->SetBranchAddress("brNSystNucl_PilessDcyRES",&reweight1);
    cout<<"in ReWeight"<<endl;
  */
#endif

    Br=tree->GetBranch("fDefaultReco.");
    Br->SetAddress(&evt);
    tree->SetBranchAddress("fDefaultReco.",&evt);

 
    ////////////////////////////////////////////////START THE LOOP//////////////////////////////////////////////////

    for(int ievt=0;ievt<nevt;ievt++){//loop over INGRID event (ingridsimvertex if MC, integration cycle of 580ns if data)
    if((ievt%100)==0) cout<<"Processing "<<ievt<<endl;
      evt->Clear("C");
      tree->GetEntry(ievt);//charge l'evt grace au link avec la branche
    
      for(int ibas=0;ibas<LimitRecs;ibas++){
	for(int itrk=0;itrk<LimitTracks;itrk++){
	  TrackAngle[ibas][itrk]=-1;
	  TrackWidth[ibas][itrk]=-1;
	  TypeOfTrack[ibas][itrk]=-1;
	  CLMuon[ibas][itrk]=-1;
	  NHits_PMIng[ibas][itrk]=0;
	  NHits_PMSci[ibas][itrk]=0;
	  NHits_Ing[ibas][itrk]=0;
	  LastChannelINGRIDX[ibas][itrk]=-1;
	  LastChannelINGRIDY[ibas][itrk]=-1;
	  Momentum[ibas][itrk]=-1;
	  ID[ibas][itrk]=-1;
	  PD[ibas][itrk]=-1;
	  Sample[ibas][itrk]=-1;
	  IsReconstructed[ibas][itrk]=false;
	  GT[ibas][itrk]=false;
	  CriteriaHalfWayX[ibas][itrk]=-1;
	  CriteriaHalfWayY[ibas][itrk]=-1;
	  CriteriaAngleX[ibas][itrk]=-1;
	  CriteriaAngleY[ibas][itrk]=-1;
	}
	VIsDetected[ibas]=false;
	VSelectionFV[ibas]=false;
	VSelectionOV[ibas]=false;
	VnTracks[ibas]=-1;
      }
    
      NIngBasRec=-1;
      TrueAngleMuon=-1;
      TrueMomentumMuon=-1;
      IsFV=false;
      IsDetected=false;
      FSIInt=-1;
      Num_Int=-1;
      nTracks=0;
      weight=0;
      Enu=0;
      GoodSpill=0;
      Spill=0;
     
#ifdef XSEC_ERROR
      /*
      //if(ievt%100==0) cout<<"Xsec nevents="<<weightstree->GetEntries()<<endl;
      if(a!=0){
	if(reweight->GetSize()!=NDials) cout<<"Problem: change NDials="<<NDials<<" in the CC0pi code"<<endl;
	weightstree->GetEntry(ievt);
	if(ievt%100==0) cout<<endl<<"*************************************************************************************************"<<endl;
	for(int i=0;i<reweight->GetSize();i++){
	  ReWeight[i]=reweight->GetAt(i);
	  int BinError= (int) (i/7);
	  if(ievt%100==0){
	    if(BinError==22) cout<<" The Bin ";
	    cout<<ReWeight[i]<<", ";
	  }
	  if(ReWeight[i]!=ReWeight[i]) cout<<"********************************************************************************************************************************************************************************************************************************************"<<endl;
	}
	if(ievt%100==0) cout<<endl<<endl;
      }
*/
#endif






     
      /////////////////////////////////////DEFINE THE WEIGHT AND TRUE VERTEX PROPERTIES AND TRUE MUON TRUE PROPERTIES//////////////////////////////
      simver = (IngridSimVertexSummary*)(evt->GetSimVertex(0));//il y a un numéro. On peut donc bien avoir plusieurs simvert/periode d'integ ;-)?
      int mod;
      double TrueVertexPosition[3]={0,0,0};
      double norm;
      double totcrsne;

      if(MC){
	Nu_E=simver->nuE;
	Enu=Nu_E;
	Num_Int=simver->inttype;
	mod=simver->mod;
	TrueVertexPosition[0]=simver->xnu;
	TrueVertexPosition[1]=simver->ynu;
	TrueVertexPosition[2]=simver->znu;
#ifdef DEBUG
	cout<<"TrueVertexPosition[0]="<<TrueVertexPosition[0]<<", TrueVertexPosition[1]="<<TrueVertexPosition[1]<<", TrueVertexPosition[2]="<<TrueVertexPosition[2]+120<<endl;
#endif
	 norm=simver->norm;
	 totcrsne=simver->totcrsne;
	 weight = 1;
	 if(IntModule==2) weight=norm*totcrsne*pow(10.,-38.)*6.02*pow(10.,23.)*46.2;
	 else if(IntModule==7) weight=norm*totcrsne*pow(10.,-38.)*6.02*pow(10.,23.)*(2.2*470);
	 else weight=norm*totcrsne*pow(10.,-38.)*6.02*pow(10.,23.)*7.87*58.5;
	 FluxTot+=norm;
	 Flux->Fill(1,norm);
	 FSIInt=XS->Xsec::DetermineFSI(evt);
	 vector <double> MuonTrue = Rec->Reconstruction::GetTrueMuonInformation(evt);
	 TrueAngleMuon=MuonTrue[1];
	 TrueMomentumMuon=MuonTrue[0];
	 IsFV=Rec->Reconstruction::IsFV(mod,TrueVertexPosition[0],TrueVertexPosition[1],TrueVertexPosition[2]);
      }
      else weight = Cor->GetMCCorrections(1,mod);

      POT=0;
      int utime=0;
      ///////////////////////////////////////////////////////////////////////////////////////////////////////////////





      /////////////////////////////////////COUNT THE NUMBER OF POT/////////////////////////////////////////
      for(int ib=0;ib<evt->NIngridBeamSummarys();ib++){
	BeamSummary = evt->GetBeamSummary(ib);
	utime=BeamSummary->trg_sec;
	for( int cyc=Scyc; cyc<Ncyc; cyc++ ){
	  POTCount->Fill(1,BeamSummary->ct_np[4][cyc-4+1]);
	  POT+=BeamSummary->ct_np[4][cyc-4+1];
	}
	if(BeamSummary->good_spill_flag==1) GoodSpill=1;
	if(BeamSummary->spill_flag==1) Spill=1;
      }
      ///////////////////////////////////////////////////////////////////////////////////////////////////////////////





      //////////////////////////////////START THE LOOP ON THE RECONSTRUCTION (RECONSTRUCTED VERTEXES////////////////

      NIngBasRec= evt->NPMAnas();
      for(int irec=0;irec<NIngBasRec;irec++){//loop on reconstruction: considered as same event => same time cluster, vertex reconstructed...
	recon = (PMAnaSummary*) evt->GetPMAna(irec);	
	nTracks=recon->Ntrack;


	///////////////////////////////SELECTIONS ARE DEFINED AND CHECKED///////////////////////////

	Rec->Reconstruction::GetSelectionPM(&VSelectionFV[irec],&VSelectionOV[irec],recon,MC);
	/////////////////////////////////////////////////////////////////////////////////////





	//////////////////////////////////////PROPERTIES OF ALL THE RECONSTRUCTION AND ALL TRACKS OF IT///////////////////////////
	vector <Hit3D> VecTrk;
	VecTrk.clear();
	VecTrk=Rec->Reconstruction::Hit2DMatchingAllTracksPM(recon);//Contains all hits in the reconstruction
	double RecVertexPosition[3]={0,0,0};//For now, the vertex is defined for each track separately!!!

	vector< vector<Hit3D> > VecDouble;
	for(int i=0;i<VecDouble.size();i++) VecDouble[i].clear();
	for(int itrk=0;itrk<nTracks;itrk++){
	  vector <Hit3D> VecT;
	  VecT.clear();
	  HitV.clear();
	  HitV=Rec->Reconstruction::EraseDoubleHitsPM(recon,itrk,HitV);
	  VecT=Rec->Reconstruction::Hit2DMatchingPM(evt,recon,HitV,VecT,MC);
	  VecDouble.push_back(VecT);
	}
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



	/////////////////////////////////////////// INITIALISE THE VARIABLES ATTACHED TO INFORMATION ON THE TRACK///////////////
	  if(Disp) cout<<endl<<"FSIInt="<<FSIInt<<", ntracks="<<nTracks<<endl;

	  vector <int> InteractionTracks;
	  InteractionTracks.clear();
	  vector <int> InteractionRecTracks;
          InteractionRecTracks.clear();
	  vector <int> InteractionSample;
          InteractionSample.clear();
	  vector <int> InteractionAngle;
          InteractionAngle.clear();

	  bool Geom=false;

	  vector <double> Kinematic;
	  Kinematic.clear();
	  vector <RecTrack> VRecTrack;
	  VRecTrack.clear();	

	  IsDetected=true;
	  VIsDetected[irec]=true;
	  VnTracks[irec]=nTracks;
	////////////////////////////////////////////////////////////////////////////////////////////	








	for(int itrk=0;itrk<nTracks;itrk++){//loop on track
	  RecVertexPosition[0]=(recon->x)[itrk]/10;
	  RecVertexPosition[1]=(recon->y)[itrk]/10;
	  RecVertexPosition[2]=VecTrk.front().z;

	  HitV.clear(); 
	  vector <Hit3D> Vec;
	  vector <Hit3D> Vec2;
	  vector <Hit3D> VecAll;
	 

	  /*************************Vec contains 3D Hits without any double counted******************************/
	  HitV=Rec->Reconstruction::EraseDoubleHitsPM(recon,itrk,HitV);
	  Vec=Rec->Reconstruction::Hit2DMatchingPM(evt,recon,HitV,Vec,MC);
	  Vec=Rec->CountSharedHits(Vec,VecDouble,itrk);//fill used
	
	  if(Vec.size()==0){
	    cout<<"Stopped because no Hits are corresponding"<<endl;
	    continue;
	  }
	  if(Disp){
	    for(int ihit=0;ihit<Vec.size();ihit++){
	      cout<<"Track="<<itrk<<", Mod="<<Vec[ihit].mod<<", pln="<<Vec[ihit].pln<<", view="<<Vec[ihit].view<<", NRJ="<<Vec[ihit].pe<<endl;
	    }
	  }


	  /*******************************************Geometric properties of the tracks are estimated******************************/
	    double AngleX,AngleY,dx;
	    vector <double> GeomVariables;
	    GeomVariables.clear();
            GeomVariables=Rec->Reconstruction::GetTrackAngle(Vec);
            dx=GeomVariables[2];
	    dx=1./TMath::Cos(DegRad((recon->angle)[itrk]));



	    /****************************************Determine the Criteria for matching tracks*************************************/
	    vector <double> CriteriaPMINGRID=Rec->Reconstruction::GetMatchingPMINGRID(Vec);
	    CriteriaAngleX[irec][itrk]=TMath::Abs(CriteriaPMINGRID[4]-CriteriaPMINGRID[0]);
	    CriteriaAngleY[irec][itrk]=TMath::Abs(CriteriaPMINGRID[5]-CriteriaPMINGRID[1]);
	    CriteriaHalfWayX[irec][itrk]=TMath::Abs(CriteriaPMINGRID[6]-CriteriaPMINGRID[2]);
	    CriteriaHalfWayY[irec][itrk]=TMath::Abs(CriteriaPMINGRID[7]-CriteriaPMINGRID[3]);


	    if(SystematicPE){
	      int ChanType;
	      int BinAngle=(int) ((recon->angle)[itrk]/3);
	      for(int ihit=0;ihit<Vec.size();ihit++){
		if(Vec[ihit].mod==16 && IsINGRID(Vec[ihit].ch)) ChanType=1;
		else if(Vec[ihit].mod==16) ChanType=2;
		else ChanType=3;

		if(BinAngle>=14) BinAngle=14;
		Vec[ihit].pecorr+=Vec[ihit].pecorr*Random[ChanType-1][BinAngle];
	      }
	    }





	    ///////////////////////////////////////// DETERMINE THE TRACK TOPLOGY AND DISTANCES CROSSED IN IRON AND CARBON/////////////////
	    //1. Determine if the track should have reached INGRID if linearly extrapolated
	    Geom=Rec->Reconstruction::HasGeomTrack(16,(recon->startxpln)[itrk],(recon->startxch)[itrk],DegRad((recon->thetax)[itrk]), (recon->startypln)[itrk],(recon->startych)[itrk],DegRad((recon->thetay)[itrk]));
	    //2. Determine the track sample
	    TrackSample=Rec->Reconstruction::SelectTrackSample((recon->pm_stop)[itrk],Geom,(recon->ing_trk)[itrk],(recon->ing_stop)[itrk],(recon->ing_endpln)[itrk]);
	    //3. Search for INGRID hits aligned with tracks in the PM, in the case the latter is not matched w/ any INGRID track
	                  /********************************Here 3D hits are reconstructed, but not only those from the track, all those of the reconstruction************************/
	    VecAll=Rec->Reconstruction::Hit2DMatchingClusterPM(evt,recon);	   
            VecAll=Rec->Reconstruction::IsInTrk(VecAll,VecTrk);
	                  /*******************************They are used to determine if tracks stops in INGRID in the first iron plane (before being reconstructed)*************/
	    //Vec=Rec->Reconstruction::SearchIngridHit(Vec,VecAll,DegRad((recon->thetax)[itrk]), DegRad((recon->thetay)[itrk]),TrackSample);

	    	    /****************************************Attenuation from the dx in the scintillator is applied*************************/
            Vec=Cor->Corrections::GetFiberAttenuation(Vec);
	    sort(Vec.begin(),Vec.end());
	    
	    /*
	    for(int i=0;i<Vec.size();i++){
	    
	      if(Vec[i].mod==16 && Reco->Reconstruction::IsINGRID(Vec[i].mod,Vec[i].pln,Vec[i].ch)) Vec[i].pecorr=f_PMIng->GetRandom();
	      else if(Vec[i].mod==16 && !(Reco->Reconstruction::IsINGRID(Vec[i].mod,Vec[i].pln,Vec[i].ch))) Vec[i].pecorr=f_PMSci->GetRandom(); 
	      else if(!(Vec[i].mod==16)) Vec[i].pecorr=f_Ing->GetRandom();
	    
	      cout<<Vec[i].mod<<", plane="<<Vec[i].pln<<", view="<<Vec[i].view<<", chan="<<Vec[i].ch<<", x="<<Vec[i].x<<", y="<<Vec[i].y<<", pe="<<Vec[i].pe<<", corr="<<Vec[i].pecorr<<", Particle="<<Vec[i].pdg<<endl;
	    }
*/
	    (recon->ing_startpln)[itrk]=0;
	    (recon->ing_endpln)[itrk]=Vec.back().pln;
	    //4. Determine the distance crossed in Plastic and Iron by the track
	    vector <double> Dist;//
	    Dist=Rec->Reconstruction::TrackPenetrationPM((recon->startxpln)[itrk],(recon->startxch)[itrk], DegRad((recon->thetax)[itrk]), (recon->startypln)[itrk],(recon->startych)[itrk], DegRad((recon->thetay)[itrk]),(recon->endxpln)[itrk],(recon->endxch)[itrk],(recon->endypln)[itrk],(recon->endych)[itrk],(recon->ing_startmod)[itrk],(recon->ing_startpln)[itrk], (recon->ing_endpln)[itrk],dx,(recon->pm_stop)[itrk]);
	    if((recon->ing_endpln)[itrk]>=9) Dist[1]=58.5/TMath::Cos(DegRad((recon->angle)[itrk]));
	    else Dist[1]=6.5*((recon->ing_endpln)[itrk]-(recon->ing_startpln)[itrk])/TMath::Cos(DegRad((recon->angle)[itrk]));
	    if((recon->ing_endpln)[itrk]<2 && recon->ing_trk[itrk]) cout<<"ONLY 2 PLANES"<<endl;
	    if(dx!=dx || dx==0) {cout<<"Problem in dx evaluation"<<endl;continue;}   
	    if((recon->ing_startmod)[itrk]!=(recon->ing_endmod)[itrk]){cout<<"Stopped because Ingrid module is changing"<<endl;continue;}

	    if(Disp) cout<<"Track Number="<<itrk<<endl;
	    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	   





	    
	    ///////////////////////////////////Determine the particle true associated to the reconstructed track/////////////////////
	    double TrkLength = Rec->Reconstruction::GetTrackLength(Vec);
	    //cout<<"Track Length="<<TrkLength<<endl;
	    int Particle =-1;
	    TrueParticleNRJ=-1;
	    if(MC){
	      int SimPartNumber=Rec->Reconstruction::GetTrackParticle(evt, recon, itrk, TrkLength);
	      SimPart=(IngridSimParticleSummary*) evt->GetSimParticle(SimPartNumber);
	      Particle =SimPart->pdg;
	      TrueParticleNRJ=TMath::Sqrt(SimPart->momentum[0]*SimPart->momentum[0]+SimPart->momentum[1]*SimPart->momentum[1]+SimPart->momentum[2]*SimPart->momentum[2]);
	    }

	    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


	   
	    /***********************************************FILL THE VARIABLES*********************************************/          
	    double CL=XS->Xsec::GetMuCL(CL_Ing,CL_PMIng,CL_PMSci,Vec, dx, TrackSample,SystematicPE, RandomIteration);
	    /*
	    for(int i=0;i<Vec.size();i++){
	      if(Vec[i].view!=0) continue;
	      if(Vec[i].mod==16){
		if(Rec->Reconstruction::IsINGRID(Vec[i].mod,Vec[i].pln,Vec[i].ch)){
		  if(Vec[i].y<40){
		    LowX+=Vec[i].pe;
		    n_LowX++;
		  }
		  else if(Vec[i].y>80){
		    HighX+=Vec[i].pe;
		    n_HighX++;
		  }
		}
	      }
	      else{
		if(Vec[i].y<40){
		  LowX_Ing+=Vec[i].pe;
		  n_LowX_Ing++;
		}
		else if(Vec[i].y>80){
		  HighX_Ing+=Vec[i].pe;
		  n_HighX_Ing++;
		}
	      }
	    }		
	    */
		
	    /*	    
	    cout<<setprecision(4)<<"CL="<<CL<<", KS="<<(recon->mucl)[itrk]<<endl;
	    cout<<"Number of hits="<<Vec.size()<<endl;
	    double thetax=(recon->thetax)[itrk]; double thetay=(recon->thetay)[itrk];
	    double intcptx=(recon->zx)[itrk]; double intcpty=(recon->zy)[itrk];
	    double gradx=TMath::ATan(thetax*TMath::Pi()/180.);
	    double grady=TMath::ATan(thetay*TMath::Pi()/180.);
	    
	    //cout<<"Angle="<<(recon->angle)[itrk]<<", angleX="<<(recon->thetax)[itrk]<<", thetaY="<<(recon->thetay)[itrk]<<", dx="<<dx<<endl;
	    //double LA=244;
	    //cout<<"View 0: Average L="<<Vec[(int) (Vec.size()/2)].y<<", correction="<<TMath::Exp(-(120-Vec[(int) (Vec.size()/2)].y)/LA)<<endl;
	    //cout<<"View 1: Average L="<<Vec[(int) (Vec.size()/2)].x<<", correction="<<TMath::Exp(-(120-Vec[(int) (Vec.size()/2)].x)/LA)<<endl;
	    const double LA=241.7;
	    double L;
	     
	    cout<<"(intcpt,grad)="<<intcpty<<", "<<grady<<endl;

	    for(int i=0;i<Vec.size();i++){
	      //Vec[ihit].pecorr=Vec[ihit].pe/TMath::Exp(-L/LAtt);
		  if(Vec[i].view==0){
		    L=(120-Vec[i].y);
	 	    cout<<Vec[i].mod<<", pln="<<Vec[i].pln<<", ch="<<Vec[i].ch<<", pe="<<Vec[i].pe<<", pecorr="<<Vec[i].pecorr/dx<<", dx="<<dx<<", att="<<Vec[i].pe/Vec[i].pecorr<<", L="<<L<<", z="<<Vec[i].z<<endl;
		  }
		}
		
		cout<<"(intcpt,grad)="<<intcptx<<", "<<gradx<<endl;
		for(int i=0;i<Vec.size();i++){
		  if(Vec[i].view==1){
		     L=(120-Vec[i].x);
		    cout<<Vec[i].mod<<", pln="<<Vec[i].pln<<", ch="<<Vec[i].ch<<", pe="<<Vec[i].pe<<", pecorr="<<Vec[i].pecorr/dx<<", dx="<<dx<<", att="<<Vec[i].pe/Vec[i].pecorr<<", L="<<L<<", z="<<Vec[i].z<<endl;
		  }
		}
	    
	      cout<<endl;

	      if(Disp){
		  //if(TrackSample>=3 && Particle!=13){
		  cout<<"Final selection ="<<Particle<<endl;
		  VecAll=Rec->Reconstruction::ClusterPM(evt,recon, nTracks);	
		  double Slpe[2]={GeomVariables[3],GeomVariables[7]};
		  double b[2]={GeomVariables[4],GeomVariables[8]};
		  double Zi[2]={GeomVariables[5],GeomVariables[9]};
		  double Zf[2]={GeomVariables[6],GeomVariables[10]};
		  EvtDisp(Vec);
		  //}
		}
*/

	      vector <double> LastChan;
	LastChan=Rec->Reconstruction::GetLastINGRIDChannel(Vec,TrackSample);
	LastChannelINGRIDY[irec][itrk]=LastChan[0];
	LastChannelINGRIDX[irec][itrk]=LastChan[1];


	TrackAngle[irec][itrk]=(recon->angle)[itrk];
	TrackWidth[irec][itrk]=Rec->Reconstruction::GetINGRIDTrackWidth(Vec);
	GT[irec][itrk]=Geom;
	IsReconstructed[irec][itrk]=true;
	TypeOfTrack[irec][itrk]=Particle;
	CLMuon[irec][itrk]=CL;
	Momentum[irec][itrk]=TrueParticleNRJ;
	PD[irec][itrk]=Dist[0];
	if(TrackSample>=2) ID[irec][itrk]=Dist[1];
	else ID[irec][itrk]=0;
	Sample[irec][itrk]=TrackSample;

	Vec.clear();
	Vec2.clear();
	VecAll.clear();
	}//Tracks
      }//Recons
      wtree->Fill(); 
    }//Evt
    Br->Delete();
	    cout<<"PM, Low="<<LowX/n_LowX<<", High="<<HighX/n_HighX<<" /// INGRID, Low="<<LowX_Ing/n_LowX_Ing<<", High="<<HighX_Ing/n_HighX_Ing<<endl;
  
    wfile->cd();
    wtree  -> Write();
    wfile  -> Write();
    wfile  -> Close();
    //theApp.Run();    
    return(0);
}
  
