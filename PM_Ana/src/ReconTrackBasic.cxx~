#ifndef _RECONTRACKBASIC_CXX
#define _RECONTRACKBASIC_CXX


#include"ReconTrackBasic.hxx"

ReconTrackBasic::ReconTrackBasic(){
  for(int i=0; i<INGRIDHIT_MAXHITS; i++){
    hit[i]     = new IngridHitSummary();
  }
  for(int i=0; i<max_ntrack; i++){
    for(int v=0; v<2; v++){
      ftrkxy[v][i] = new IngridTrackSummary();
    }
    ftrk[i] = new IngridTrackSummary();
  }
  Clear();
}

ReconTrackBasic::~ReconTrackBasic(){
}

bool ReconTrackBasic::Clear(){
  for(int v=0; v<2; v++){
    vpe[v] = 0;
    n_trk[v] = 0;
    ftplistrk[v]   = false;
    uvetohashit[v] = false;
    uedgeistrk[v]  = false;
  }

  for(int i=0; i<INGRIDHIT_MAXHITS; i++){
    hit[i]      = 0;
  }
  for(int i=0; i<max_ntrack; i++){
    for(int v=0; v<2; v++){
      ftrkxy[v][i]->Clear();
    }
    ftrk[i]->Clear();
  }
  nhits     = 0;
  n_match   = 0;
}
bool ReconTrackBasic::SetHit( TRef inghit[] ){
  nhits = 0;
  while(1){
    if( inghit[nhits] != 0 )
      nhits++;
    else
      break;
  }
  //### Get IngridHitSummarys #######
  //#################################
  for( int i=0; i<nhits; i++ ){
    hit[i] = (IngridHitSummary*)inghit[i].GetObject(); 
  }
  //### Get md_pln(most down stream active TPL) ###
  //###############################################
  for(int p = nTPL - 1; p >= 0; p-- ){
    vector<int> h = fTdcHit(0, p);
    vector<int> v = fTdcHit(1, p);
    if(h.size()>0 && v.size()>0){
      md_pln[0] = p;
      md_pln[1] = p;
      break;
    }
  }

}

vector<int> ReconTrackBasic::fTdcHit(int view, int pln){
  vector<int> hitch;
  hitch.clear();
  for(int i=0; i<nhits; i++){
    if( hit[i] -> pln == pln &&
	hit[i] -> view == view)
      hitch.push_back( hit[i]->ch );
  }
  return hitch;
}


bool ReconTrackBasic::Last3TPL(int v){
  trk_point[v].clear();
  //#### Get Last active 3 TPLs ####
  //################################
  int            p = md_pln[v];
  vector<int>   ch[3];
  int         mpln[3];
  int temp =0;

  while( 1 ){
    vector<int> tempx, tempy;
    tempx.clear(); tempy.clear();
    tempx = fTdcHit( FromX, p );
    tempy = fTdcHit( FromY, p );
    if( tempx.size()>0 && tempy.size()>0 ){
      ch  [temp] = fTdcHit( v, p );
      mpln[temp] = p;
      temp++;
    }
    p--;
    if( p < 0 ||
	temp > 2 )
      break;
  }
  int i,j,k;


  cout<<"view:" <<v <<" 3TPLs"<<endl;
  cout<<mpln[0]<<"\t"<<mpln[1]<<"\t"<<mpln[2]<<endl;


  for(i = 0; i < ch[0].size(); i++){
    for(j = 0; j < ch[1].size(); j++){
      int diff01 = ch[0][i] - ch[1][j];
      for( k = 0; k < ch[2].size(); k++){
	int diff12 = ch[1][j] - ch[2][k];
	if( diff01 == diff12 )
	  goto Find;
      }
    }
  }

  for(i=0; i<ch[0].size(); i++){
    for(j=0; j<ch[1].size(); j++){
      int diff01 = ch[0][i] - ch[1][j];
      for(k=0; k<ch[2].size(); k++){
	int diff12 = ch[1][j] - ch[2][k];
	if( abs( diff01 - diff12 ) <= TolOfPoint )
	  goto Find;
      }
    }
  }
  
  return false;
 Find:
  trk_point[v].push_back( pair<int, int>( mpln[0], ch[0][i] ) );
  trk_point[v].push_back( pair<int, int>( mpln[1], ch[1][j] ) );
  trk_point[v].push_back( pair<int, int>( mpln[2], ch[2][k] ) );
  return true;
}

bool ReconTrackBasic::AddTrkPoint(int v, int cpln){
  int       np = trk_point[v].size();
  float chdiff = 
    1.0 * 
    ( trk_point[v][0].second - trk_point[v][np-1].second )
    /  ( trk_point[v][0].first - trk_point[v][np-1].first );
  vector<int>   ch;
  ch = fTdcHit(v, cpln);
 
  int i;
  for( i=0; i < ch.size(); i++ ){
    float diff = 
      1.0 * 
      ( trk_point[v][np-1].second - ch[i] )
      /  ( trk_point[v][np-1].first - cpln );
    if( fabs( diff - chdiff ) <= 0.5  )
      goto Find;
  }
  for( i=0; i < ch.size(); i++ ){
    float diff = 
      1.0 * 
      ( trk_point[v][np-1].second - ch[i] )
      /  ( trk_point[v][np-1].first - cpln );
    if( fabs( diff - chdiff ) <= TolOfPoint + 0.5  )
      goto Find;
  }
  return false;
 Find:
  trk_point[v].push_back( pair<int, int>( cpln, ch[i] ) );
  return true;
}

bool ReconTrackBasic::Point2Trk(int v){

  float vtxf[3] = {0,0,-1000};
  float vtxi[3] = {0,0, 1000};
  for(int i=0; i<trk_point[v].size(); i++){
    for(int j=0; j<nhits; j++){
      if( hit[j] -> view != v )
	continue;
      if( trk_point[v][i].first  == hit[j] -> pln &&
	  trk_point[v][i].second == hit[j] -> ch ){
	ftrkxy[v][n_trk[v]] -> AddIngridHit( hit[j] );

	if( hit[j]->z > vtxf[2] ){                     //### last point
	  ftrkxy[v][n_trk[v]] -> vtxf[0] = hit[j] -> xy;
	  ftrkxy[v][n_trk[v]] -> vtxf[2] = hit[j] -> z;
	  vtxf[2] = hit[j]->z;
	  vtxf[0] = hit[j]->xy;
	}
	if( hit[j]->z < vtxi[2] ){ //### initial point
	  ftrkxy[v][n_trk[v]] -> vtxi[0] = hit[j] -> xy;
	  ftrkxy[v][n_trk[v]] -> vtxi[2] = hit[j] -> z;
	  vtxi[2] = hit[j]->z;
	  vtxi[0] = hit[j]->xy;
	  vpe[v]  = hit[j]->pe;
	}

	break;
      }// it is track point
    }
  }


  (ftrkxy[v][n_trk[v]])->length = 
    1.0 * sqrt( ( vtxf[0] - vtxi[0] )*( vtxf[0] -vtxi[0] ) + ( vtxf[2] - vtxi[2] )*( vtxf[2] -vtxi[2] ) ) ; 
    //pow( (vtxf[0] - vtxi[0]),2 ) + pow( (vtxf[2] - vtxi[2]),2 );

  FitTrack(*ftrkxy[v][n_trk[v]]);

  n_trk[v]++;

}

bool ReconTrackBasic::FitTrack(IngridTrackSummary& trk){
  float Sxx=0, Sx=0, Sxy=0, Sy=0, S=0;
  int nhits = trk.NHits();
  for( Int_t i = 0 ; i < nhits ; i++){
    IngridHitSummary* hita = (IngridHitSummary*)trk.GetIngridHit(i);
    float              xy  = hita -> xy;
    float               z  = hita ->  z;
    S++;
    Sx  += z;
    Sxx += pow(z,2);
    Sy  += xy;
    Sxy += xy * z;
  }//i
  float a = ( S * Sxy - Sx * Sy )/( S * Sxx - pow(Sx, 2) );
  float b = ( Sxx * Sy - Sxy * Sx )/( S * Sxx - pow(Sx, 2) );
  float chi2=0;
  for( Int_t i = 0 ; i < nhits ; i++){
    IngridHitSummary* hita = (IngridHitSummary*)trk.GetIngridHit(i);
    float              xy  = hita -> xy;
    float               z  = hita ->  z;
    chi2 += pow( xy - ( a * z + b ), 2 ); 
  }//i
  trk. tx  = a;
  trk. etx = b;
  trk. chi2x = chi2;
}

bool ReconTrackBasic::FirstTPLisTrack(int v){
  int np = trk_point[v].size();
  for( int i=0; i<np; i++ ){
    if( trk_point[v][i].first == 0 )
      return true;
 
  }
  return false;
}
bool ReconTrackBasic::UVETOisTrack(int v){ //### Not Ready
  return false;

}
bool ReconTrackBasic::UVETOhasHit(int v){
  int z0     = GetInitialZ (v);
  int xy0    = GetInitialXY(v);
  float zpos = 1.0 * z0 * ( IronThick + PlnThick ); 
 
  //if( xy0 != 0 && xy0 != 23 )
  if( xy0 <= 1 && xy0 >= 22 )
    return false;
 
  for( int i = 0; i<nhits; i++ ){
    int   p = hit[i] -> pln;
    float z = hit[i] -> z;
    if( z < zpos ){
      if( xy0 == 0  ){ //#### Bottom or Right VETO 
	if( ( p == BVETO && v == FromX ) ||
	    ( p == RVETO && v == FromY ) )
	  return true;
	  }
      if( xy0 == 23 ){ //#### Upper or Left VETO 
	if( ( p == UVETO && v == FromX ) ||
	    ( p == LVETO && v == FromY ) )
	  return true;
      }
    }
  }
  return false;
}

bool ReconTrackBasic::UEdgeisTrack(int v){
  int z0     = GetInitialZ (v);
  int xy0    = GetInitialXY(v);
  if( xy0 == 0 ||
      xy0 == 23 ){
    uedgeistrk[v]=true;
    return true;
  }
  return false;
}

int ReconTrackBasic::GetInitialZ( int v ){
  int tpl = 11;
  for(int i=0; i<trk_point[v].size(); i++){
    int t = trk_point[v][i].first;
    if( tpl > t )
      tpl = t;
  }
  return tpl;
}
int ReconTrackBasic::GetLastZ( int v ){
  int tpl = -1;
  for(int i=0; i<trk_point[v].size(); i++){
    int t = trk_point[v][i].first;
    if( tpl < t )
      tpl = t;
  }
  return tpl;
}
int ReconTrackBasic::GetInitialXY( int v ){
  int tpl = 11;
  int  ch;
  for(int i=0; i<trk_point[v].size(); i++){
    int t = trk_point[v][i].first;
    if( tpl > t ){
      tpl = t;
      ch  = trk_point[v][i].second;
    }
  }
  return ch;
}
int ReconTrackBasic::GetLastXY( int v ){
  int tpl = -1;
  int  ch;
  for(int i=0; i<trk_point[v].size(); i++){
    int t = trk_point[v][i].first;
    if( tpl < t ){
      tpl = t;
      ch  = trk_point[v][i].second;
    }
  }
  return ch;
}

bool ReconTrackBasic::AddVETOPoint(int v){
  cout<<"view:"<<v <<" Add VETO Point"<<endl;
  int       np = trk_point[v].size();
  float     z0 = 1.0 * GetInitialZ  (v) * ( IronThick + PlnThick ); 
  float     z1 = 1.0 * GetLastZ     (v) * ( IronThick + PlnThick ); 
  float    xy0 = 1.0 * GetInitialXY (v) * ScintiWidth;
  float    xy1 = 1.0 * GetLastXY    (v) * ScintiWidth;
  float  slope = ( xy1 - xy0 ) / ( z1 - z0 );
  float   cons = 0.5 * ( xy1 + xy0 ) - slope * 0.5 * ( z0 + z1 );

  for(int i=0; i<nhits; i++){
    int p = hit[i] -> pln;
    if( p < nTPL )continue; //### TPL
    if( ( v == FromX && ( p == BVETO || p == UVETO ) )|| //### VETO plane# are 13 and 14 
	( v == FromY && ( p == RVETO || p == LVETO ) )   //### VETO plane# are 11 and 12 
	){

      float  z           = hit[i] -> z;
      float  xy          = hit[i] -> xy;
      float  expected_xy = slope * z + cons;
      cout<<"VEOT z =" << z << "\t xy="<<xy << "\texpxy="<<expected_xy << endl;
      if( fabs( xy - expected_xy) < TolVetoFit ){
	int ch = hit[i] -> ch;
	trk_point[v].push_back( pair<int, int>( p, ch ) );
      }
    }

  }//nhits loop
}

bool ReconTrackBasic::TrkMatching( int n ){//### Not Ready
  cout<<"Trk Matching"<<endl;
  if( n > n_trk[ FromY ] || n > n_trk[ FromX ] )
    return false;
  //### check most upstream tracking plane hit within track
  int xz = nTPL;
  for( int i=0; i<trk_point[FromY].size(); i++ ){
    int tz = trk_point[FromY][i].first;
    if( tz >= nTPL ) continue;
    if( tz < xz )
      xz = tz;
  }
  int yz = nTPL;
  for( int i=0; i<trk_point[FromX].size(); i++ ){
    int tz = trk_point[FromX][i].first;
    if( tz >= nTPL ) continue;
    if( tz < yz )
      yz = tz;
  }
  //### match b/w X and Y view ??
  if( abs( yz - xz ) > TolOfMatching )
    return false;

  ftrk[n_match]->Clear();
  MargeTrkXY(n_match, n_match);

  n_match++;
  return true;
}

bool ReconTrackBasic::MargeTrkXY(int ntrk0, int ntrk1){//### Not Ready
  float vtxi[3]={0,0, 1000};
  float vtxf[3]={0,0,-1000};
  for( int i=0; i<ftrkxy[FromX][ntrk1]->NHits();i++){
    IngridHitSummary* th = 
      (IngridHitSummary*)ftrkxy[FromX][n_match]->GetIngridHit(i);
    ftrk[n_match] -> AddIngridHit( th );
    float xy = th -> xy;
    float  z = th ->  z;
    if( vtxi[Z] > z ){
   
    }
    if( vtxf[Z] < z ){
    }
  }
  for( int i=0; i<ftrkxy[FromY][ntrk0]->NHits();i++){
    IngridHitSummary* th = 
      (IngridHitSummary*)ftrkxy[FromY][n_match]->GetIngridHit(i);
    ftrk[n_match] -> AddIngridHit( th );
  }

  //####

}

bool ReconTrackBasic::ReconTrack(){
  bool fit0 = ReconTrackXY( FromX );
  bool fit1 = ReconTrackXY( FromY );
  if( !fit0 || !fit1 )
    return false;

  cout<<"Point"<<endl;
  Point2Trk ( FromX );
  Point2Trk ( FromY );
  //TrkMatching( 0 ); //### Now Only 1 track is reconstructed
                      //### Not Ready 
}

bool ReconTrackBasic::ReconTrackXY(int v){
  if(Last3TPL(v)){
    int cpln = md_pln[v] - 3;
    bool gap=false;
    while(1){
      bool miss = !( AddTrkPoint(v, cpln) );
      if( gap && miss ) //## current and last plane are missed
	break;
      else if( cpln == 0 )   //## last TPL
	break;
      else if( !gap && miss )     //## if current tpln is missed, gap is true
	gap = true;	  
      else if( !miss )
	gap = false;
      cpln--;
    }
    AddVETOPoint(v);
    ftplistrk[v]   = FirstTPLisTrack(v);
    uvetohashit[v] = UVETOhasHit(v);
    return true;
  }

  return false;
}

IngridTrackSummary* ReconTrackBasic::GetTrack(int v, int i) const{
  if (i < n_trk[v] && i>=0 ) return ftrkxy[v][i];
  return 0;
}


void ReconTrackBasic::Print(){
  cout <<"----------------------------------------" <<endl;
  cout << "most down stream(side,view0)" << md_pln[0] << endl;
  cout << "most down stream(top,view1)"  << md_pln[1] << endl;
  cout << "-- hit information --" << endl;
  for( int i = 0 ; i< nhits; i++){
    cout << "view:"   << hit[i] -> view
	 << "\tpln:"  << hit[i] -> pln
	 << "\tch:"   << hit[i] -> ch
	 << "\tpe:"   << hit[i] -> pe
	 <<endl;
  }  
  for( int v = 0 ; v<2; v++){
    cout<<"-- view " << v << " track info. --" << endl; 
    for( int i = 0 ; i< trk_point[v].size(); i++){
      cout << "\tpln"   << trk_point[v][i].first 
	   << "\tch"    << trk_point[v][i].second 
	   <<endl;
    }  
  }
  

  /*
  cout <<"----------------------------------------" <<endl;
  cout << "most down stream(side)" << md_pln[0] << endl;
  cout << "# of hits in view0    " << nhits0   << endl;
  cout << "View:0 # of tracks = " << n_trk0 << endl;
  for(int i=0; i<n_trk0; i++){
    cout << " *track # " << i << " ------" << endl;
    for(int j=0; j<trk_ch0_z[i].size(); j++){
      cout << "pln:"  << trk_ch0_z[i][j] 
	   << "\tch:" << trk_ch0  [i][j] 
	   << endl;
    }
  }
  */

}
#endif
