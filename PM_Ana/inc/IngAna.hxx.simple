#ifndef __INGANA_HXX__
#define __INGANA_HXX__

// ROOT includes
#include "TApplication.h"
#include "TFile.h"
#include "TH1F.h"
#include "TF1.h"
#include "TGraph.h"
#include "TH2F.h"
#include "TCanvas.h"
#include <TStyle.h>
#include "TString.h"
#include "TSystem.h"
#include "TSpectrum.h"
#include "TTree.h"
//C++ libraly includes
#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <cstdio>
#include <iostream>
#include <sstream>
#include <fstream>
#include <iomanip.h>
#include <algorithm>
#include <deque>
#include <vector>
#include <sys/stat.h>
#include <unistd.h> // using getopt      
using namespace std;
// INGRID includes


//__________________________________________________________


class IngTrack{
public:
  Int_t    startxpln;
  Int_t    startypln;
  Int_t    startxch;
  Int_t    startych;
  Int_t    endxpln;
  Int_t    endypln;
  Int_t    endxch;
  Int_t    endych;
  Int_t    vertexz;
  Int_t    vertexxz;
  Int_t    vertexyz;
  Float_t  thetax;
  Float_t  thetay;
  Float_t  angle;
  Float_t  clstime;
  Float_t  x;
  Float_t  y;
  Float_t  z;
  Float_t  zx;
  Float_t  zy;
  Bool_t   vetowtracking; // Upstream VETO
  Bool_t   edgewtracking; // Fiducial CUT
  Bool_t   vtxtrk;

  void clear(){
    startxpln=  -1;
    startypln=  -1;
    startxch=  -1;
    startych=  -1;
    endxpln=  -1;
    endypln=  -1;
    endxch=  -1;
    endych=  -1;
    vertexz=  -1;
    vertexxz=  -1;
    vertexyz=  -1;
    thetax=  -1.e-5;
    thetay=  -1.e-5;
    angle=  -1.e-5;
    clstime=  -1.e-5;
    x=  -1.e-5;
    y=  -1.e-5;
    z=  -1.e-5;
    zx=  -1.e-5;
    zy=  -1.e-5;
    vetowtracking = false; // Upstream VETO
    edgewtracking = false; // Fiducial CUT
    vtxtrk = true;
  }
};

vector<IngTrack> ingtrack;
vector<Track> htrack;
vector<Track> vtrack;


void fIngAna(int mod){
  IngTrack track;
  ingtrack.clear();
  vector<int> id_h,id_v,track_h,track_v;
  vector<bool> tracked_h,tracked_v,used_h,used_v;
  tracked_h.clear();tracked_v.clear();
  for(int i=0;i<htrack.size();i++)tracked_h.push_back(false);
  for(int j=0;j<vtrack.size();j++)tracked_v.push_back(false);
  for(int dif=0;dif<2;dif++){
    for(int pln=0;pln<plnmax(mod)-1;pln++){
      id_h.clear();id_v.clear();
      used_h.clear();used_v.clear();
      for(int i=0;i<htrack.size();i++){
	if(tracked_h[i])continue;
	//if(htrack[i].ipln!=pln)continue;
	if((htrack[i].ipln-pln)>dif||(htrack[i].ipln-pln)<0)continue;
	id_h.push_back(i);
	used_h.push_back(false);
      }
      for(int j=0;j<vtrack.size();j++){
	if(tracked_v[j])continue;
	//if(abs(vtrack[j].ipln-pln)>dif)continue;
	if((vtrack[j].ipln-pln)>dif||(vtrack[j].ipln-pln)<0)continue;
	id_v.push_back(j);
	used_v.push_back(false);
      }

      track_h.clear();track_v.clear();
      for(int ddif=0;ddif<plnmax(mod)-1;ddif++){
	for(int dpln=plnmax(mod)-1;dpln>=0;dpln--){
	  for(int i=0;i<id_h.size();i++){
	    if((htrack[id_h[i]].fpln-dpln)>ddif||(htrack[id_h[i]].fpln-dpln)<0)continue;
	    for(int j=0;j<id_v.size();j++){
	      if(htrack[id_h[i]].clstime!=vtrack[id_v[j]].clstime)continue;
	      if(used_h[i])continue;
	      if(used_v[j])continue;
	      if((vtrack[id_v[j]].fpln-dpln)>ddif||(vtrack[id_v[j]].fpln-dpln)<0)continue;
	      track_h.push_back(id_h[i]);
	      track_v.push_back(id_v[j]);
	      used_h[i]=true;
	      used_v[j]=true;
	    }
	  }
	}
      }


      for(int k=0;k<track_h.size();k++){
	int h=track_h[k];
	int v=track_v[k];
	
	tracked_h[h]=true;
	tracked_v[v]=true;
	
	track.startxpln     = htrack[h].ipln;
	track.startypln     = vtrack[v].ipln;
	track.startxch      = (int)htrack[h].ixy/50;
	track.startych      = (int)vtrack[v].ixy/50;
	track.endxpln       = htrack[h].fpln;
	track.endypln       = vtrack[v].fpln;
	track.endxch        = (int)htrack[h].fxy/50;
	track.endych        = (int)vtrack[v].fxy/50;
	
	if(htrack[h].ipln<vtrack[v].ipln){
	  track.vertexz       = htrack[h].ipln;
	  track.z             = htrack[h].iz;
	}
	else{
	  track.vertexz       = vtrack[v].ipln;
	  track.z             = vtrack[v].iz;
	}
	
	track.vertexxz      = htrack[h].ipln;
	track.vertexyz      = vtrack[v].ipln;
	track.zx            = htrack[h].iz;
	track.zy            = vtrack[v].iz;
	track.y             = htrack[h].ixy;
	track.x             = vtrack[v].ixy;
	track.thetax        = htrack[h].ang;
	track.thetay        = vtrack[v].ang;
	track.angle         = 180/3.14159265*atan(sqrt(pow(tan(htrack[h].ang*3.14159265/180),2)+pow(tan(vtrack[v].ang*3.14159265/180),2)));
	track.clstime       = htrack[h].clstime;
	track.vetowtracking = (htrack[h].veto||vtrack[v].veto);
	track.edgewtracking = (htrack[h].edge||vtrack[v].edge);

	track.vtxtrk = true;

	ingtrack.push_back(track);
	
      }



    }
  }
};


#endif
