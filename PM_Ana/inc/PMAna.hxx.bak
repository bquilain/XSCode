#ifndef __PMANA_HXX__
#define __PMANA_HXX__

// ROOT includes
#include "TApplication.h"
#include "TFile.h"
#include "TH1F.h"
#include "TF1.h"
#include "TGraph.h"
#include "TH2F.h"
#include "TCanvas.h"
#include <TStyle.h>
#include "TString.h"
#include "TSystem.h"
#include "TSpectrum.h"
#include "TTree.h"
//C++ libraly includes
#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <cstdio>
#include <iostream>
#include <sstream>
#include <fstream>
#include <iomanip.h>
#include <algorithm>
#include <deque>
#include <vector>
#include <sys/stat.h>
#include <unistd.h> // using getopt      
using namespace std;
// INGRID includes
#include "PMrecon.hxx"

//__________________________________________________________

class TrackPM{
public:
  
  Int_t     view;
  Int_t     ipln;
  Int_t     fpln;
  Float_t    ixy;
  Float_t    fxy;
  Float_t     iz;
  Float_t     fz;
  Float_t  slope;
  Float_t intcpt;
  Float_t    ang;
  Float_t  clstime;
  Bool_t    veto;
  Bool_t    edge;
  Bool_t    stop;  
  Int_t    ing_imod;
  Int_t    ing_fmod;
  Int_t    ing_ipln;
  Int_t    ing_fpln;
  Bool_t   ing_trk;
  Bool_t   pm_stop;
  Bool_t   ing_stop;
  Int_t    iron_pene;
  
  
  void clear(){
    view   =  -1;
    ipln   =  -1;
    fpln   =  -1;
    ixy    =  -1.e-5;
    fxy    =  -1.e-5;
    iz     =  -1.e-5;
    fz     =  -1.e-5;
    slope  =  -1.e-5;
    intcpt =  -1.e-5;
    ang    =  -1.e-5;
    clstime=  -1.e-5;
    veto   = false;
    edge   = false;
    stop   = false;
    ing_imod = -1;
    ing_fmod = -1;
    ing_ipln = -1;
    ing_fpln = -1;
    ing_trk = false;
    pm_stop = false;
    ing_stop = false;
    iron_pene = -1;
    
  }
};



class PMTrack{
public:

  Int_t Ntrack;
  Int_t Ningtrack;
  Float_t  clstime;
  Bool_t   vetowtracking; // Upstream VETO
  Bool_t   edgewtracking; // Fiducial CUT

  vector<Int_t>    startxpln;
  vector<Int_t>    startypln;
  vector<Float_t>    startxch;
  vector<Float_t>    startych;
  vector<Int_t>    endxpln;
  vector<Int_t>    endypln;
  vector<Float_t>    endxch;
  vector<Float_t>    endych;
  vector<Float_t>  thetax;
  vector<Float_t>  thetay;
  vector<Float_t>  angle;
  vector<Int_t>    ing_startmod;
  vector<Int_t>    ing_endmod;
  vector<Int_t>    ing_startpln;
  vector<Int_t>    ing_endpln;
  vector<Bool_t>   ing_trk;
  vector<Bool_t>   pm_stop;
  vector<Bool_t>   ing_stop;
  vector<Float_t>  sci_range;
  vector<Float_t>  iron_range;
  vector<Int_t>    iron_pene;
 

  void clear(){
    Ntrack = -1;
    Ningtrack = -1;
    clstime = -1.e-5;
    vetowtracking=false; // Upstream VETO
    edgewtracking=false; // Fiducial CUT
    startxpln.clear();
    startypln.clear();
    startxch.clear();
    startych.clear();
    endxpln.clear();
    endypln.clear();
    endxch.clear();
    endych.clear();
    thetax.clear();
    thetay.clear();
    angle.clear();
    ing_startmod.clear();
    ing_endmod.clear();
    ing_startpln.clear();
    ing_endpln.clear();
    ing_trk.clear();
    pm_stop.clear();
    ing_stop.clear();
    sci_range.clear();
    iron_range.clear();
    iron_pene.clear();
  }
};


vector<PMTrack> pmtrack;
vector<TrackPM> htrack;
vector<TrackPM> vtrack;
vector<Track> hingtrack;
vector<Track> vingtrack;
vector<Hit> hhits;
vector<Hit> vhits;


bool withend(const TrackPM& left, const TrackPM& right){
  if(left.fpln != right.fpln)
    return left.fpln > right.fpln;
  else if(left.ipln != right.ipln)
    return left.ipln < right.ipln;
  else
    return fabs(left.ang) < fabs(right.ang);
};

bool withcenter(const Track& left, const Track& right){
  if(abs(left.mod-3) != abs(right.mod-3))
    return abs(left.mod-3) < abs(right.mod-3);
  else if(left.ipln != right.ipln)
    return left.ipln < right.ipln;
  else if(left.fpln != right.fpln)
    return left.fpln > right.fpln;
  else
    return fabs(left.ang) < fabs(right.ang);
};

bool fSortTrack(vector<TrackPM> &a){
  std::stable_sort(a.begin(), a.end(), withend);
};

bool fIngSortTrack(vector<Track> &a){
  std::stable_sort(a.begin(), a.end(), withcenter);
};

bool fIngPMJoint(vector<Track> &itrk, vector<TrackPM> &ptrk, bool vertical){
  float diff_ang, diff_pos,joilik=-1e-5;
  int joitra=-1;
  bool jointed;
  bool hasingtrk=false;
  for(int j=0;j<itrk.size();j++){

    jointed=false;

    for(int i=0;i<ptrk.size();i++){
      
      if(itrk[j].mod==3){
	if(itrk[j].ipln>1)continue;
	if(ptrk[i].fpln<16)continue;
      }
      else if(vertical){
	if(itrk[j].ipln>1&&(!itrk[j].veto)&&(!itrk[j].edge))continue;
	if(ptrk[i].fpln<16&&ptrk[i].stop)continue;
      }

      diff_ang=ptrk[i].ang-itrk[j].ang;
      diff_pos=(ptrk[i].intcpt+ptrk[i].slope*946.75)-(itrk[j].intcpt+itrk[j].slope*946.75);//zpos = (1079.5+814)/2
      
      if(fabs(diff_ang)<35&&fabs(diff_pos)<85){

	if(jointed){
	  if(joilik>sqrt(fabs(diff_ang)*fabs(diff_ang)/35/35+fabs(diff_pos)*fabs(diff_pos)/85/85))	   
	    ptrk[joitra].ing_trk=false;

	  else
	    continue;
	}

	if(ptrk[i].ing_trk == false){
	  ptrk[i].ing_imod   = itrk[j].mod;
	  ptrk[i].ing_fmod   = itrk[j].mod;
	  ptrk[i].ing_ipln   = itrk[j].ipln;
	  ptrk[i].ing_fpln   = itrk[j].fpln;
	  ptrk[i].ing_trk    = true;
	  ptrk[i].ing_stop   = itrk[j].stop;
	  
	  if(hingtrack[j].fpln==10)
	    ptrk[i].iron_pene  = itrk[j].fpln - itrk[j].ipln-1;
	  else
	    ptrk[i].iron_pene  = itrk[j].fpln - itrk[j].ipln;
	}
	
	else{
	  if(abs(itrk[j].mod-3) <= abs(ptrk[i].ing_fmod-3))continue;
	  if(itrk[j].ipln < ptrk[i].ing_fpln)continue;
	  
	  ptrk[i].ing_fmod   = itrk[j].mod;
	  ptrk[i].ing_fpln   = itrk[j].fpln;
	  ptrk[i].ing_stop   = itrk[j].stop;
	  
	  if(hingtrack[j].fpln==10)
	    ptrk[i].iron_pene  += itrk[j].fpln - itrk[j].ipln-1;
	  else
	    ptrk[i].iron_pene  += itrk[j].fpln - itrk[j].ipln;
	}
	

	jointed=true;
	joitra=i;
	joilik=sqrt(fabs(diff_ang)*fabs(diff_ang)/35/35+fabs(diff_pos)*fabs(diff_pos)/85/85);
	hasingtrk=true;

      }//if
    }//ptrk
  }//itrk

  return hasingtrk;
};


bool fPMAna(){
  PMTrack track;
  pmtrack.clear();

  if(htrack.size()==0||vtrack.size()==0)return false;

  fIngSortTrack(hingtrack);
  fIngSortTrack(vingtrack);
  fSortTrack(htrack);
  fSortTrack(vtrack);

  if(!fIngPMJoint(hingtrack,htrack,false))return false;
  if(!fIngPMJoint(vingtrack,vtrack,true))return false;


  vector<int> id_h,id_v,track_h,track_v;
  vector<bool> tracked_h,tracked_v,used_h,used_v;
  tracked_h.clear();tracked_v.clear();
  for(int i=0;i<htrack.size();i++)tracked_h.push_back(false);
  for(int j=0;j<vtrack.size();j++)tracked_v.push_back(false);
  for(int dif=0;dif<4;dif++){
    for(int pln=0;pln<plnmax(16)-1;pln++){//16 means PM
      id_h.clear();id_v.clear();
      used_h.clear();used_v.clear();
      for(int i=0;i<htrack.size();i++){
	if(!htrack[i].ing_trk)continue;
	if(tracked_h[i])continue;
	if((htrack[i].ipln-pln)>dif||(htrack[i].ipln-pln)<0)continue;
	id_h.push_back(i);
	used_h.push_back(false);
      }
      for(int j=0;j<vtrack.size();j++){
	if(!vtrack[j].ing_trk)continue;
	if(tracked_v[j])continue;
	if((vtrack[j].ipln-pln)>dif||(vtrack[j].ipln-pln)<0)continue;
	id_v.push_back(j);
	used_v.push_back(false);
      }

      track_h.clear();track_v.clear();
      for(int ddif=0;ddif<plnmax(3)-1;ddif++){
	for(int dpln=plnmax(3)-1;dpln>=0;dpln--){
	  for(int i=0;i<id_h.size();i++){
	    if((htrack[id_h[i]].ing_fpln-dpln)>ddif||(htrack[id_h[i]].ing_fpln-dpln)<0)continue;
	    for(int j=0;j<id_v.size();j++){
	      if(htrack[id_h[i]].clstime!=vtrack[id_v[j]].clstime)continue;
	      if(used_h[i])continue;
	      if(used_v[j])continue;
	      if((vtrack[id_v[j]].ing_fpln-dpln)>ddif||(vtrack[id_v[j]].ing_fpln-dpln)<0)continue;
	      track_h.push_back(id_h[i]);
	      track_v.push_back(id_v[j]);
	      used_h[i]=true;
	      used_v[j]=true;
	    }
	  }
	}
      }//ddif

      for(int k=0;k<track_h.size();k++){
	int h=track_h[k];
	int v=track_v[k];
	
	tracked_h[h]=true;
	tracked_v[v]=true;
	
	track.startxpln.push_back(htrack[h].ipln);
	track.startypln.push_back(vtrack[v].ipln);
	track.startxch.push_back(htrack[h].ixy);
	track.startych.push_back(vtrack[v].ixy);
	track.endxpln.push_back(htrack[h].fpln);
	track.endypln.push_back(vtrack[v].fpln);
	track.endxch.push_back(htrack[h].fxy);
	track.endych.push_back(vtrack[v].fxy);	
	
	track.thetax.push_back(htrack[h].ang);
	track.thetay.push_back(vtrack[v].ang);

	float trkang=180/3.14159265*atan(sqrt(pow(tan(htrack[h].ang*3.14159265/180),2)+pow(tan(vtrack[v].ang*3.14159265/180),2)));

	track.angle.push_back(trkang);
	track.clstime=(htrack[h].clstime+htrack[v].clstime)/2;
	track.vetowtracking=(htrack[h].veto||vtrack[v].veto);
	track.edgewtracking=(htrack[h].edge||vtrack[v].edge);
       
	if(abs(vtrack[v].ing_imod-3)<abs(htrack[h].ing_imod-3))
	  track.ing_startmod.push_back(vtrack[v].ing_imod);
	else
	  track.ing_startmod.push_back(htrack[h].ing_imod);

	if(abs(vtrack[v].ing_fmod-3)>abs(htrack[h].ing_fmod-3))
	  track.ing_endmod.push_back(vtrack[v].ing_fmod);
	else
	  track.ing_endmod.push_back(htrack[h].ing_fmod);

	if(vtrack[v].ing_ipln<htrack[h].ing_ipln)
	  track.ing_startpln.push_back(vtrack[v].ing_ipln);
	else
	  track.ing_startpln.push_back(htrack[h].ing_ipln);

	if(vtrack[v].ing_fpln>htrack[h].ing_fpln)
	  track.ing_endpln.push_back(vtrack[v].ing_fpln);
	else
	  track.ing_endpln.push_back(htrack[h].ing_fpln);

	track.ing_trk.push_back((htrack[h].ing_trk||vtrack[v].ing_trk));
	track.pm_stop.push_back((htrack[h].stop&&vtrack[v].stop));
	track.ing_stop.push_back((htrack[h].ing_stop&&vtrack[v].ing_stop));

	if(vtrack[v].iron_pene>htrack[h].iron_pene){
	  track.iron_pene.push_back(vtrack[v].iron_pene);
	  track.iron_range.push_back(vtrack[v].iron_pene/cos(trkang*3.14159265/180));
	}
	else{
	  track.iron_pene.push_back(htrack[h].iron_pene);
	  track.iron_range.push_back(htrack[h].iron_pene/cos(trkang*3.14159265/180));
	}

	if((vtrack[v].fpln-vtrack[v].ipln)>(htrack[h].fpln-htrack[h].ipln))
	  track.sci_range.push_back((vtrack[v].fpln-vtrack[v].ipln)/cos(trkang*3.14159265/180));
	else
	  track.sci_range.push_back((htrack[h].fpln-htrack[h].ipln)/cos(trkang*3.14159265/180));

	pmtrack.push_back(track);


      }//for

    }//pln
  }//dif


  int pln_th  =2;
  float ch_th =150;

  /*
  for(int i=0;i<pmtrack.size();i++){
    for(int j=i+1;j<pmtrack.size();j++){

      if(abs((pmtrack[i].startxpln[0])-(pmtrack[j].startxpln[0]))+abs((pmtrack[i].startypln[0])-(pmtrack[j].startypln[0]))>pln_th)continue;
      if(fabs((pmtrack[i].y[0])-(pmtrack[j].y[0])+fabs((pmtrack[i].x[0])-(pmtrack[j].x[0])))>ch_th)continue;


      if(!(pmtrack[i].vtxtrk)||!(pmtrack[j].vtxtrk))continue;

      if((pmtrack[i].vetowtracking||pmtrack[i].edgewtracking)&&
	 (pmtrack[j].vetowtracking||pmtrack[j].edgewtracking)&&
	 (pmtrack[i].endxpln[0]+pmtrack[i].endypln[0])<(pmtrack[j].endxpln[0]+pmtrack[j].endypln[0])){
	pmtrack[i].vtxtrk = false;
	pmtrack[j].Ntrack += pmtrack[i].Ntrack;
      }
      else if((pmtrack[i].vetowtracking||pmtrack[i].edgewtracking)&&
	      (pmtrack[j].vetowtracking||pmtrack[j].edgewtracking)){
	pmtrack[j].vtxtrk = false;
	pmtrack[i].Ntrack += pmtrack[j].Ntrack;
      }     
      else if(pmtrack[j].vetowtracking||pmtrack[j].edgewtracking){
	pmtrack[i].vtxtrk = false;
	pmtrack[j].Ntrack += pmtrack[i].Ntrack;
      }
      else if(pmtrack[i].vetowtracking||pmtrack[i].edgewtracking){
	pmtrack[j].vtxtrk = false;
	pmtrack[i].Ntrack += pmtrack[j].Ntrack;
      }
      else if((pmtrack[i].endxpln[0]+pmtrack[i].endypln[0])<(pmtrack[j].endxpln[0]+pmtrack[j].endypln[0])){
	pmtrack[i].vtxtrk = false;
	pmtrack[j].Ntrack += pmtrack[i].Ntrack;
      }
      else{
	pmtrack[j].vtxtrk = false;
	pmtrack[i].Ntrack += pmtrack[j].Ntrack;
      }



    }
  }
  */

};


#endif
