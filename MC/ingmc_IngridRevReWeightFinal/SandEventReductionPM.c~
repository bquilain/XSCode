
#include<iostream>
#include<sstream>
#include<fstream>
using namespace std;
#include <iomanip>
#include <sys/stat.h>
#include <cmath>
#include <TError.h>
#include <TF1.h>
#include <TROOT.h>
#include <TStyle.h>
#include <TApplication.h>
#include <TFile.h>
#include <TCanvas.h>
#include <TTree.h>
#include <TClonesArray.h>
#include <TObject.h>
#include <TEventList.h>
#include <TBranch.h>
#include <TRandom3.h>
#include <TH1.h>
#include <TH2.h>
#include <TH3.h>
#include <TVector.h>
#include <TLegend.h>
#include <TGraph.h>
#include <TGaxis.h>
#include <TMarker.h>
#include <TText.h>
#include <TMath.h>
#include <TSpectrum.h>
#include <TBox.h>
#include <TLatex.h>
#include <TString.h>
#include <TSystem.h>
#include <THStack.h>
int LimitTracks=100;
int LimitRecs=10;
int NDials=175;
#include "TApplication.h"
#include "INGRIDEVENTSUMMARY.h"
#include "IngridHitSummary.h"
#include "IngridSimHitSummary.h"
#include "IngridSimVertexSummary.h"
#include "IngridSimParticleSummary.h"
#include "BeamInfoSummary.h"
#include "IngridBasicReconSummary.h"
#include "INGRID_Dimension.cc"
INGRID_Dimension * IngDim = new INGRID_Dimension();
#include "setup.h"
#include "Hit.h"
#include "PMdispRev.h"
#include "Corrections.cc"
#include "Reconstruction.cc"
Reconstruction * Rec = new Reconstruction();
Corrections * Cor = new Corrections();

//#define DEBUG
//#define XSEC_ERROR
//#define GENERATEWIDTH
//double C[17]={-1.85,0.34,0.59,0.74,0.514,-0.37,1.25,-0.06,0.562,0.82,-0.47,0.6,-0.57,-0.45};
bool IsINGRID(int ch){
  bool Ing;
  if(ch<=7||ch>=24) Ing=true;
  else Ing=false;
  return Ing;
}

int GetMax(vector <int> V){
  int Max;
  if(V[0]>V[1] && V[0]>V[2]) Max=0;
  else if(V[0]>V[1] && V[0]<V[2])Max=2;
  else if(V[0]<V[1] && V[1]>V[2])Max=1;
  else if(V[0]<V[1] && V[1]<V[2])Max=2;
  return Max;
}

double DegRad(double angle){
  return angle*TMath::Pi()/180.;
}

double RadDeg(double angle){
  return angle*180./TMath::Pi();
}
//

int main(int argc, char **argv)
{
  bool Disp=false;
  int NFiles=100;
  int IFiles=1;
  int c=-1;
  bool MC=false;
  bool SystematicPE=false;
  int RandomIteration;
  string RandomIteration_string;

  while ((c = getopt(argc, argv, "i:f:")) != -1) {
    switch(c){
    case 'i':
      IFiles=atoi(optarg);
      break;
    case 'f':
      NFiles=atoi(optarg);
      break;
    }
  }
  char * NameFolder = new char[256];
  char *intStr = new char[256];
  sprintf(intStr,"/%d/",NFiles);
  string NFiles_string = string(intStr);

  cout<<"Welcome"<<endl;
  vector <HitTemp> HitV;
  TApplication theApp("App",0,0);

  int type;//0=CC, 1=NC
  double Nu_E;
  char File[256];char FileW[256];
  float MeV2PE=46.0; //MIP9
  double TrueParticleNRJ=0;
  int IntNumber=0;

  int FSIInt=-1;
  int Num_Int=-1;
  int nTracks=-1;
  float weight=1;
  bool IsFV=false;
  bool IsDetected=false;
  bool IsSand=false;
  float POT;
  float Enu;
  float TrueAngleMuon;
  float TrueMomentumMuon;
  int NIngBasRec;
  TFile * _InputEff_Ingrid;
  TH1D * InputEff_Ingrid;
  TFile * _InputEffMC_Ingrid;
  TH1D * InputEffMC_Ingrid;

  TFile * _InputEff_SciBar;
  TH1D * InputEff_SciBar;
  TFile * _InputEffMC_SciBar;
  TH1D * InputEffMC_SciBar;

  TRandom3 * Rand = new TRandom3();
  
  cout<<"Opening Events"<<endl;

  for(int a=0;a<1;a++){
  
    //gErrorIgnoreLevel = Error;
    for(int n=IFiles;n<=NFiles;n++){//Loop over different files
      //   if(a==0) sprintf(File,"/export/scraid2/data/bquilain/MCfiles/PM_MC_Sand%d_BirksCorrectedMIP40_ReWeight_wNoise_KSana_woXTalk.root",n); 
       if(a==0) sprintf(File,"/export/scraid2/data/bquilain/MCfiles/PM_MC_Sand%d_BirksCorrectedMIP40_ReWeight_SciBar188_wNoise_KSana_woXTalk.root",n); 
       else if(a==1) sprintf(File,"/export/scraid2/data/bquilain/MCfiles/PM_MC_Beam%d_BirksCorrectedMIP40_ReWeight_wNoise_KSana_woXTalk.root",n);
      
      sprintf(FileW,"/export/scraid2/data/bquilain/MCfiles/PM_MC_Sand%d_BirksCorrectedMIP40_ReWeight_SciBar188_wNoise_KSana_woXTalk_Reduced.root",n);
      TFile*            wfile = new TFile(FileW, "recreate");
    TTree*            wtree = new TTree("tree","tree");
    wtree -> SetMaxTreeSize(5000000000);
    IngridEventSummary* evt = new IngridEventSummary();
    wtree              -> Branch   ("fDefaultReco.","IngridEventSummary",
                                  &evt,  64000,  99);
  
    TFile * _file0=new TFile(File);
    if(_file0->IsOpen()) cout << _file0->GetName() <<" is open"<< endl ;
    else continue;
    TTree * tree=(TTree*) _file0->Get("tree");
    if(tree!=tree) continue;
    int nevt=(int) tree->GetEntries();
    cout<<"Total Number Of Events="<<nevt<<endl;

    //   IngridEventSummary* evt = new IngridEventSummary();
    TBranch * Br=tree->GetBranch("fDefaultReco.");
    Br->SetAddress(&evt);
    tree->SetBranchAddress("fDefaultReco.",&evt);

    for(int ievt=0;ievt<nevt;ievt++){//loop over INGRID event (ingridsimvertex if MC, integration cycle of 580ns if data)
      if((ievt%100)==0) cout<<"Processing "<<ievt<<endl;
      evt->Clear();
      tree->GetEntry(ievt);//charge l'evt grace au link avec la branche
      NIngBasRec= evt->NPMAnas();
      if(NIngBasRec==0) continue;
      wtree->Fill();
    }
  wfile->cd();
  wtree->Write();
  wfile->Close();

  /*  delete wfile;
  delete wtree;
  delete evt;*/
    }
  }
  return(0);
}
  
